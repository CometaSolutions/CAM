/*
 * Copyright 2014 Stanislav Muhametsin. All rights Reserved.
 *
 * Licensed  under the  Apache License,  Version 2.0  (the "License");
 * you may not use  this file  except in  compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed  under the  License is distributed on an "AS IS" BASIS,
 * WITHOUT  WARRANTIES OR CONDITIONS  OF ANY KIND, either  express  or
 * implied.
 *
 * See the License for the specific language governing permissions and
 * limitations under the License. 
 */
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading;

namespace UtilPack
{
   ///// <summary>
   ///// This is helper class to hold multiplexed values of <see cref="Multiplexer"/>.
   ///// </summary>
   ///// <typeparam name="T">The type of the values to hold.</typeparam>
   //public class MultiplexerValueHolder<T>
   //   where T : class
   //{
   //   private T _value;
   //   private readonly Func<T, T, T> _combiner;
   //   private readonly Func<T, T, T> _remover;

   //   /// <summary>
   //   /// Creates a new instance of <see cref="MultiplexerValueHolder"/> with given callbacks for combining and removal, and optional starting value.
   //   /// </summary>
   //   /// <param name="combiner">The callback to use when combining two values in <see cref="Add"/> method.</param>
   //   /// <param name="remover">The callback to use when removing one value from another in <see cref="Remove"/> method.</param>
   //   /// <param name="value">The optional initial value for this <see cref="MultiplexerValueHolder"/>.</param>
   //   public MultiplexerValueHolder( Func<T, T, T> combiner, Func<T, T, T> remover, T value = null )
   //   {
   //      ArgumentValidator.ValidateNotNull( "Combiner callback", combiner );
   //      ArgumentValidator.ValidateNotNull( "Remover callback", remover );

   //      this._combiner = combiner;
   //      this._remover = remover;
   //      this._value = value;
   //   }

   //   public void Add( T value )
   //   {
   //      // Very much like code generated by C# compiler for event addition
   //      T current = this._value;
   //      T oldCurrent;
   //      do
   //      {
   //         oldCurrent = current;
   //         var newValue = this._combiner( oldCurrent, value );
   //         current = Interlocked.CompareExchange<T>( ref this._value, newValue, oldCurrent );
   //      }
   //      while ( !Object.ReferenceEquals( current, oldCurrent ) );
   //   }

   //   public void Remove( T value )
   //   {
   //      // Very much like code generated by C# compiler for event removal
   //      T current = this._value;
   //      T oldCurrent;
   //      do
   //      {
   //         oldCurrent = current;
   //         var newValue = this._remover( oldCurrent, value );
   //         current = Interlocked.CompareExchange<T>( ref this._value, newValue, oldCurrent );
   //      }
   //      while ( !Object.ReferenceEquals( current, oldCurrent ) );
   //   }
   //}

   /// <summary>
   /// This class represents abstract multiplexor of values based on keys.
   /// </summary>
   /// <typeparam name="TKey">The type of keys to base multiplexing on.</typeparam>
   /// <typeparam name="TValue">The type of values being multiplexed.</typeparam>
   /// <remarks>
   /// The values being multiplexed are assumed to have the feature of being of same type whether they represent many or one specific thing.
   /// One example of this kind of type is <see cref="Delegate"/>: it will be of the same type whether it has one or many handlers.
   /// </remarks>
   public abstract class Multiplexer<TKey, TValue>
   {
      private readonly Dictionary<TKey, TValue> _dictionary;

      /// <summary>
      /// Creates a new instance of <see cref="Multiplexer{T,U}"/> with given combiner and remover callbacks, and optional equality comparer for keys.
      /// </summary>
      /// <param name="equalityComparer">The optional equality comparer for keys.</param>
      public Multiplexer( IEqualityComparer<TKey> equalityComparer = null )
      {
         this._dictionary = new Dictionary<TKey, TValue>( equalityComparer );
      }

      /// <summary>
      /// Multiplexes given value for given key.
      /// </summary>
      /// <param name="key">The key.</param>
      /// <param name="value">The value to multiplex.</param>
      /// <remarks>Will do nothing if <paramref name="value"/> is <c>null</c>.</remarks>
      public void AddValueFor( TKey key, TValue value )
      {
         if ( value != null )
         {
            lock ( this._dictionary )
            {
               TValue existing;
               if ( this._dictionary.TryGetValue( key, out existing ) )
               {
                  existing = this.Combine( existing, value );
               }
               else
               {
                  existing = value;
               }
               this._dictionary[key] = existing;
            }
         }
      }

      /// <summary>
      /// De-multiplexes given value for given key.
      /// </summary>
      /// <param name="key">The key.</param>
      /// <param name="value">The value to de-multiplex.</param>
      /// <remarks>Will do nothing if <paramref name="value"/> is <c>null</c>.</remarks>
      public void RemoveValueFor( TKey key, TValue value )
      {
         if ( value != null )
         {
            lock ( this._dictionary )
            {
               TValue existing;
               if ( this._dictionary.TryGetValue( key, out existing ) )
               {
                  existing = this.Remove( existing, value );
                  if ( existing == null )
                  {
                     this._dictionary.Remove( key );
                  }
                  else
                  {
                     this._dictionary[key] = existing;
                  }
               }
            }
         }
      }

      /// <summary>
      /// Tries to get the multiplexed value for given key.
      /// </summary>
      /// <param name="key">The key.</param>
      /// <param name="value">This will contain the multiplexed value, if return value of this method is <c>true</c>.</param>
      /// <returns><c>true</c> if there was something multiplexed for given <paramref name="key"/>; <c>false</c> otherwise.</returns>
      public Boolean TryGetMultiplexedValue( TKey key, out TValue value )
      {
         return this._dictionary.TryGetValue( key, out value );
      }

      /// <summary>
      /// Gets a snapshot of all the keys of this multiplexer.
      /// </summary>
      /// <value>A snapshot of all the keys of this multiplexer.</value>
      public TKey[] KeysSnapshot
      {
         get
         {
            lock ( this._dictionary )
            {
               return this._dictionary.Keys.ToArray();
            }
         }
      }

      /// <summary>
      /// Gets a snapshot of all the values of this multiplexer.
      /// </summary>
      /// <value>A snapshot of all the values of this multiplexer.</value>
      public TValue[] ValuesSnapshot
      {
         get
         {
            lock ( this._dictionary )
            {
               return this._dictionary.Values.ToArray();
            }
         }
      }

      /// <summary>
      /// Gets a snapshot of multiplexer dictionary.
      /// </summary>
      /// <value>A snapshot of multiplexer dictionary.</value>
      public IDictionary<TKey, TValue> Snapshot
      {
         get
         {
            lock ( this._dictionary )
            {
               return new Dictionary<TKey, TValue>( this._dictionary, this._dictionary.Comparer );
            }
         }
      }

      /// <summary>
      /// Subclasses should implement this method which will be used to combine existing and new value into one.
      /// </summary>
      /// <param name="existing">The currently existing value.</param>
      /// <param name="newValue">The new value to add to existing.</param>
      /// <returns>The combined value of <paramref name="existing"/> and <paramref name="newValue"/></returns>
      protected abstract TValue Combine( TValue existing, TValue newValue );

      /// <summary>
      /// Subclasses should implement this method which will be used to remove value from existing value combination.
      /// </summary>
      /// <param name="existing">The currently existing value.</param>
      /// <param name="removable">The value to remove.</param>
      /// <returns>The <paramref name="existing"/> value without <paramref name="removable"/>.</returns>
      protected abstract TValue Remove( TValue existing, TValue removable );
   }
}
