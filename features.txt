# Introduction
This git repository is home for CILAssemblyManipulator (CAM) framework, UtilPack library, and CILMerge utility.

# NuGet packages
For people just looking links for NuGet packages:
* UtilPack: http://www.nuget.org/packages/UtilPack
* CAM.Physical: Coming soon
* CAM.Logical: Coming soon
* CAM.Structural: Coming soon

# UtilPack library
This is small and extremely portable library that contains various miscellaneous utility types and methods that I find to be essential in most of my projects, both personal and professional.
In that sense, it is much like [Jon Skeet's Miscellaneous Utility Library](http://www.yoda.arachsys.com/csharp/miscutil/).
However, the UtilPack is also extremely portable; the supported platforms are .NET 4, SL5, WPSL8, WPA8.1, and Win8.
Most of the documentation can be found in the XML documentation file included in the NuGet package, or by browsing source code directly.
Some things on TODO list:
* Various lazies (ReadOnlyLazy, SettableLazy, ResettableLazy)
* More tests.

# CILAssemblyManipulator framework
The purpose of CILAssemblyManipulator (CAM) framework is to provide modifiable views onto CIL metadata on various abstraction levels.
There are three abstraction levels in CAM are, from least abstract to most abstract:
* Physical,
* Structural,
* and Logical.
Each abstraction level is represented by one library.
All libraries are very extremely portable; the supported platforms are .NET 4, SL5, WPSL8, WPA8.1, and Win8.

The common guidelines that API on all abstraction levels adhers:
* Freeform, meaning that minimum amount of constraints (like ECMA metadata uniqueness/ordering constraints) are applied on API level,
* [KISS](https://en.wikipedia.org/wiki/KISS_principle) types, meaning that the types contain usually mostly simple data access methods/properties, and extension methods provide the more complicated functionality.

Because of the freeform feature, it is possible to have (and write to disk) invalid metadata.
The responsibility of producing valid metadata is left for user of the framework, be that manually ensuring some of the metadata constraints, or by simply calling methods that restructure the metadata so that at least some constraints are being adhered to then.
One notable example of such method is `OrderTablesAndRemoveDuplicates` extension method for `CILMetaData` type in CAM.Physical library.

* Meant as alternative to Cecil ( https://github.com/jbevain/cecil ).

## CAM.Physical library
* Metadata is represented as modifiable tables and signatures
* Follows very closely the specifications and abstraction level of ECMA-335 document
* Because of the low abstraction level, very lightweight and quick
* Methods to modify metadata to conform to most of the ECMA metadata uniqueness/ordering constraints
* Not threadsafe
* Equality comparison is exact: two metadata instances may be considered different even if they produce exactly equivalently behaving code
* Note: If you are looking for extremely quick framework providing *read-only* access ECMA metadata with similar abstraction level as CAM.Physical, you should use System.Reflection.Metadata package ( http://www.nuget.org/packages/System.Reflection.Metadata/ ), if you are able to (e.g. your PCL profile matches the one of System.Reflection.Metadata)

## CAM.Structural library
* Metadata is represented as modifiable objects, the concept of metadata tables is no longer present
* Quite lightweight and quick
* Follows very closely the specifications of ECMA-335 document (e.g. TypeRefs can have custom attributes, etc), but abstraction level is somewhat higher than CAM.Physical
* Not threadsafe
* Equality comparison is exact, but on this abstraction level this means that two metadata instances producing equivalently behaving code will be considered equal
* This abstraction level roughly equals the one of the Cecil
* Extension methods to create Structural-level metadata from Physical-level metadata, and vice versa, are provided.

## CAM.Logical library
* Metadata is represented as modifiable objects, structure and abstraction level of which resembles those of System.Reflection namespace
* API is not so lightweight anymore
* Requires a concept of 'universe', which is represented by 'CILReflectionContext' interface
* The universe can be threadsafe or not threadsafe
** Threadsafety here means making generic methods/types and element types. Modifying types, properties, etc is never threadsafe within the scope of that type. For example, it is always threadsafe (even in non-threadsafe universe) to add nested types to different enclosing types. However, it is never threadsafe to add types to same enclosing type, or to add a global type.
* Equality comparison is by-reference within the universe (also meaning that two methods representing the same method are always the same instance, just like in System.Reflection)

# CILMerge utility
* Uses CAM.Physical to merge multiple CIL assemblies into one, similar to ILMerge ( http://research.microsoft.com/en-us/people/mbarnett/ilmerge.aspx ) and ILRepack ( https://github.com/gluck/il-repack ).
* Available as MSBuild task and as standalone executable.
* Has support of /closed and /align options
* Some feautes missing though:
** Win32 resources
** MDB support (is this relevant anymore?)
** Regex-based type renaming
** BAML fixing
** IKVM exports
